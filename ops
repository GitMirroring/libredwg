{"version":1,"ops":[{"type":6,"author":{"id":"b57a4f5420adf835b8b83469143e813bd4f12c78"},"timestamp":1544602910,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDE2MTQ5NDUxNA=="},"target":"5c7c5b8fb7b3f9dfe6d1487cecb85cbb4fb51371c07018b2052bb10b29ddcbce","message":"With large DWG's with large offsets from handles, some offsets were misrepresented due to underflow. The last byte (4 bit actually) were not read.\n\nMC:\nRead 1 modular char (max 5 bytes, signed).\nRead bytes until the high bit of the byte is 0, drop the highest bit and pad with 0.\nIf the last byte has 0x40 set, it's negative.\nSince the result is int32_t (4 byte), but there needs to be the high/follow bit set,\nthe stream can be max 5 byte long (5*7 = 35 bit)\n```\n    10000000 10000000 10000000 10000000 00000100\n =\u003e  0000000  0000000  0000000  0000000  0000100 (5*7 = 35)\n =\u003e 00001000 00000000 00000000 00000000          (4*8 = 32)\n```\nWith 4 byte only 4*7=28 bit can be represented, the highest 4 (from 32) are missing for large offsets.\n\nDetected and fixed by @DenisPryt in #65","files":null},{"type":6,"author":{"id":"b57a4f5420adf835b8b83469143e813bd4f12c78"},"timestamp":1544603167,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDE2MTQ5NjEzMw=="},"target":"5c7c5b8fb7b3f9dfe6d1487cecb85cbb4fb51371c07018b2052bb10b29ddcbce","message":"With large DWG's with large offsets from handles, some offsets were misrepresented due to underflow. The last byte (4 bit actually) were not read.\n\nMC:\nRead 1 modular char (max 5 bytes, signed).\nRead bytes until the high bit of the byte is 0, drop the highest bit and pad with 0.\nIf the last byte has 0x40 set, it's negative.\nSince the result is int32_t (4 byte), but there needs to be the high/follow bit set,\nthe stream can be max 5 byte long (5*7 = 35 bit)\n```\n    10000000 10000000 10000000 10000000 00000100\n =\u003e  0000000  0000000  0000000  0000000  0000100 (5*7 = 35)\n =\u003e 00001000 00000000 00000000 00000000          (4*8 = 32)\n```\nWith 4 byte only 4*7=28 bit can be represented, the highest 4 (from 32) are missing for large offsets \u003e= 0x1000000 (0b0001000000000000000000000000)\n\nDetected and fixed by @DenisPryt in #65","files":null},{"type":6,"author":{"id":"b57a4f5420adf835b8b83469143e813bd4f12c78"},"timestamp":1544604903,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDE2MTUwNzQxNw=="},"target":"5c7c5b8fb7b3f9dfe6d1487cecb85cbb4fb51371c07018b2052bb10b29ddcbce","message":"With large DWG's with large offsets from handles, some offsets were misrepresented due to underflow. The last byte (4 bits actually) was not read.\n\nMC:\nRead 1 modular char (max 5 bytes, signed).\nRead bytes until the high bit of the byte is 0, drop the highest bit and pad with 0.\nIf the last byte has 0x40 set, it's negative. (since the 0x80 bit is dropped, 0x40 becomes the highest then)\nSince the result is int32_t (4 byte), but there needs to be the high/follow bit set,\nthe stream can be max 5 byte long (5*7 = 35 bit)\n```\n    10000000 10000000 10000000 10000000 00000100\n =\u003e  0000000  0000000  0000000  0000000  0000100 (5*7 = 35)\n =\u003e 00001000 00000000 00000000 00000000          (4*8 = 32)\n```\nWith 4 byte only 4*7=28 bit can be represented, the highest 4 (from 32) are missing for large offsets \u003e= 0x1000000 (0b0001000000000000000000000000)\n\nDetected and fixed by @DenisPryt in #65","files":null},{"type":6,"author":{"id":"b57a4f5420adf835b8b83469143e813bd4f12c78"},"timestamp":1544605010,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDE2MTUwODIxNg=="},"target":"5c7c5b8fb7b3f9dfe6d1487cecb85cbb4fb51371c07018b2052bb10b29ddcbce","message":"With large DWG's with large offsets from handles, some offsets were misrepresented due to underflow. The last byte (4 bits actually) was not read.\n\nMC:\nRead 1 modular char (max 5 bytes, signed).\nRead bytes until the high bit of the byte is 0, drop the highest bit and pad with 0.\nIf the last byte has 0x40 set, it's negative. (since the 0x80 bit is dropped, 0x40 becomes the highest then)\nSince the result is int32_t (4 byte), but there needs to be the high/follow bit set,\nthe stream can be max 5 byte long (5*7 = 35 bit)\n```\n    10000000 10000000 10000000 10000000 00000100\n =\u003e  0000000  0000000  0000000  0000000  0000100 (5*7 = 35)\n =\u003e 00001000 00000000 00000000 00000000          (4*8 = 32)\n```\nWith 4 byte only 4*7=28 bit can be represented, the highest 4 (from 32) are missing for large offsets \u003e= 0x1000000 (0b0001000000000000000000000000)\n\nDetected and fixed by @DenisPryt in #65 \n\nThe very same error came originally from libdwg, and is also present in all other open source dwg libs:\nlibdwg, libdxfrw, pythoncad","files":null},{"type":6,"author":{"id":"b57a4f5420adf835b8b83469143e813bd4f12c78"},"timestamp":1544605083,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDE2MTUwODcyMA=="},"target":"5c7c5b8fb7b3f9dfe6d1487cecb85cbb4fb51371c07018b2052bb10b29ddcbce","message":"With large DWG's with large offsets from handles, some offsets were misrepresented due to underflow. The last byte (4 bits actually) was not read.\n\nMC:\nRead 1 modular char (max 5 bytes, signed).\nRead bytes until the high bit of the byte is 0, drop the highest bit and pad with 0.\nIf the last byte has 0x40 set, it's negative. (since the 0x80 bit is dropped, 0x40 becomes the highest bit then)\nSince the result is int32_t (4 byte) but there needs to be the high/follow bit set,\nthe stream can be max 5 byte long (5*7 = 35 bit)\n```\n    10000000 10000000 10000000 10000000 00000100\n =\u003e  0000000  0000000  0000000  0000000  0000100 (5*7 = 35)\n =\u003e 00001000 00000000 00000000 00000000          (4*8 = 32)\n```\nWith 4 byte only 4*7=28 bit can be represented, the highest 4 (from 32) are missing for large offsets \u003e= 0x1000000 (0b0001000000000000000000000000)\n\nDetected and fixed by @DenisPryt in #65 \n\nThe very same error came originally from libdwg, and is also present in all other open source dwg libs:\nlibdwg, libdxfrw, pythoncad","files":null},{"type":5,"author":{"id":"b57a4f5420adf835b8b83469143e813bd4f12c78"},"timestamp":1544602843,"metadata":{"github-id":"MDEyOkxhYmVsZWRFdmVudDIwMjA4MDg0NTI="},"added":["bug"],"removed":[]},{"type":2,"author":{"id":"b57a4f5420adf835b8b83469143e813bd4f12c78"},"timestamp":1544619213,"metadata":{"github-id":"MDE3OlJlbmFtZWRUaXRsZUV2ZW50MjAyMTQwNzEwMg=="},"title":"HEADER.HANDSEED as HEX, and DXF off value","was":"BITCODE_MC needs to read from 5 bytes, not 4"},{"type":4,"author":{"id":"b57a4f5420adf835b8b83469143e813bd4f12c78"},"timestamp":1544633993,"metadata":{"github-id":"MDExOkNsb3NlZEV2ZW50MjAyMjA2OTA2NA=="},"status":2}]}